#!/bin/bash
set -eo pipefail
shopt -s nullglob # makes globs expand to nothing if no match

## Global variables
tool=""
input=""
valid_tools=("fsl" "afni" "freesurfer" "all_any" "all_all")
expand=0
dilate=0
qc=0
num_prel=0

## Functions
printhelp(){
        echo -e "Mandatory flags:\n" \
                "\t-i input_file(s)\t: Specify one input file (nifti), a list of nifti files separated by comma, or a text file with the list of input files (all nifti).\n" \
                "\t-t tool\t\t: What tool to use. Accepted options: fsl, afni, freesurfer, all_any, all_all (case insensitive).\n" \
                "\t\t\tall_any will use all the tools and create a final mask with those voxels that are part of ANY of the masks.\n" \
                "\t\t\tall_all will use all the tools and create a final mask with those voxels that are part of ALL of the masks.\n\n" \
                \
                "Optional flags:\n" \
                "\t-h\t: Print help.\n" \
                "\t-p n\t: Process n images in parallel (only makes sense if the number of input files is >1).\n" \
                "\t-e\t: Expand the output mask(s).\n" \
                "\t-d\t: Dilate the output mask(s).\n\n" \
                "\t-q\t: Generate QC images (will take significantly longer to run).\n\n" \
                \
                "There will be two output files, the brain mask with suffix _mask, and the brain extracted file with suffix _brain.\n" \
                "Holes will be automatically filled.\n" \
                "If the input file is 4D, the output file will be too, but the mask will be based on the first volume only.\n"

        exit
}

readInputListTXT(){
        local txtfile="$1"
        local result="$2"

        # Validate arguments
        if [[ -z "$txtfile" ]] || [[ -z "$result" ]]; then
                echo "Missing arguments in readInputListTXT()" >&2
                return 1
        fi

        if [[ ! "$txtfile" == *.txt ]]; then
                echo "Input file to readInputListTXT() must be .txt" >&2
                return 1
        fi

        if [[ ! -f "$txtfile" ]]; then
                echo "${txtfile} not found" >&2
                return 1
        fi

        echo -e "\nReading input files list from ${txtfile}"
        local lines=()
        while IFS= read -r line; do
                lines+=("$line")
        done < "$txtfile"

        # Return array into result variable
        eval "$result=(\"\${lines[@]}\")"
}

processNIFTI(){
        local inputfile="$1"

        echo -e "\nProcessing ${inputfile}"

        # Check that it's not an empty string and the file exists
        if [ -z $inputfile ] || [ ! -f $inputfile ]; then
                echo "${inputfile} not found" >&2
                exit 1
        fi

        # Check that it's a nifti file
        if [[ ! "$inputfile" == *.nii ]] && [[ ! "$inputfile" == *.nii.gz ]]; then
                echo "${inputfile} is not nifti" >&2
                exit 1
        fi

        # Get suffix & prefix
        [[ $inputfile == *.nii.gz ]] && suffix=".nii.gz" || suffix=".nii"
        prefix=${inputfile%"$suffix"}

        # Pre-process 4D file if applicable
        nvols=$(fslval "$inputfile" dim4)
        nvols=${nvols/ /}
        echo "Input file has ${nvols} volumes"
        if [ "$nvols" -gt 1 ];then
                files=("$prefix"/vol????.nii.gz)
                nvsplit=${#files[@]}
                if [ "$nvsplit" -gt "$nvols" ]; then
                        echo "Splitting 4D file"
                        mkdir -p "$prefix"
                        fslsplit "$inputfile" "$prefix"/vol
                else
                        echo "4D is already split, skipping step"

                fi
        fi

        # Extract using FSL

        # Extract using AFNI

        # Extract using Freesurfer

        # Create final mask if using all tools

        # Fill holes

        # Expand if requested

        # Dilate if requested

        # Create QC images if requested

        # Post-process 4D file if applicable

	# Mask brain
}

## Main code
# Read arguments
while getopts ":ht:i:p:edq" opt
do
        case $opt in
                h) printhelp;;
                t) tool=${OPTARG,,};; # Convert OPTARG to lower case
                i) input=$OPTARG;;
                p) num_proc=$OPTARG;;
                e) expand=1;;
                d) dilate=1;;
                q) qc=1;;
                \?) echo "Invalid option: -$OPTARG" >&2; exit 1;; # Handle invalid options
                :) echo "Option -$OPTARG requires an argument." >&2; exit 1;; # Handle missing arguments for options
        esac
done

# Do checks
if [ "$input" == "" ] || [ "$tool" == "" ]; then
        echo -e "Missing mandatory flags.\n" >&2
        printhelp
fi

if ! printf '%s\0' "${valid_tools[@]}" | grep -Fxqz -- "${tool}"; then
        echo -e "${tool} is not an acceptable tool for this script.\n" >&2
        printhelp
fi

# Get the list of input files
declare -a inputArray
if [[ $input == *.txt ]]; then
        readInputListTXT "${input}" inputArray
elif [[ "$input" == *,* ]]; then
        IFS=',' read -r -a inputArray <<< "${input}"
else
        inputArray=("${input}")
fi

# Correct the size of parallel processes if greater than the number of input files
if [ "$num_proc" -gt "${#inputArray[@]}" ]
then
        echo -e "You requested to analyze ${num_proc} images in parallel, but there are only ${#inputArray[@]} images.\n \
        Number of parallel processes will be adjusted to ${#inputArray[@]}."
        num_proc=${#inputArray[@]}
fi

# Process each input file
for inputfile in "${inputArray[@]}"; do
        processNIFTI "${inputfile}"
done
