#!/usr/bin/env bash
# Author: Monica Keith
# Description: Run brain extraction on MRI brain images

set -eo pipefail
shopt -s nullglob # makes globs expand to nothing if no match

## Global variables
tool=""
input=""
valid_tools=("fsl" "afni" "freesurfer" "all_any" "all_all")
expand=0
dilate=0
qc=0
num_proc=1

## Functions
printhelp(){
        echo -e "Mandatory flags:\n" \
                "\t-i input_file(s)\t: Specify one input file (nifti), a list of nifti files separated by comma, or a text file with the list of input files (all nifti).\n" \
                "\t-t tool\t\t: What tool to use. Accepted options: fsl, afni, freesurfer, all_any, all_all (case insensitive).\n" \
                "\t\t\tall_any will use all the tools and create a final mask with those voxels that are part of ANY of the masks.\n" \
                "\t\t\tall_all will use all the tools and create a final mask with those voxels that are part of ALL of the masks.\n\n" \
                \
                "Optional flags:\n" \
                "\t-h\t: Print help.\n" \
                "\t-p n\t: Process n images in parallel (only makes sense if the number of input files is >1).\n" \
                "\t-e\t: Expand the output mask(s).\n" \
                "\t-d\t: Dilate the output mask(s).\n\n" \
                "\t-q\t: Generate QC images (will take significantly longer to run).\n\n" \
                \
                "There will be two output files, the brain mask with suffix _mask, and the brain extracted file with suffix _brain.\n" \
                "Holes will be automatically filled.\n" \
                "If the input file is 4D, the output file will be too, but the mask will be based on the first volume only.\n"

        exit
}

readInputListTXT(){
        local txtfile="$1"
        local result="$2"

        # Validate arguments
        if [[ -z "$txtfile" ]] || [[ -z "$result" ]]; then
                echo "Missing arguments in readInputListTXT()" >&2
                return 1
        fi

        if [[ ! "$txtfile" == *.txt ]]; then
                echo "Input file to readInputListTXT() must be .txt" >&2
                return 1
        fi

        if [[ ! -f "$txtfile" ]]; then
                echo "${txtfile} not found" >&2
                return 1
        fi

        echo -e "\nReading input files list from ${txtfile}"
        local lines=()
        while IFS= read -r line; do
                lines+=("$line")
        done < "$txtfile"

        # Return array into result variable
        eval "$result=(\"\${lines[@]}\")"
}

processNIFTI(){
        local inputfile="$1"

        echo "Processing ${inputfile}"

        # Check that it's not an empty string and the file exists
        if [ -z "$inputfile" ] || [ ! -f "$inputfile" ]; then
                echo "${inputfile} not found" >&2
                exit 1
        fi

        # Check that it's a nifti file
        if [[ ! "$inputfile" == *.nii ]] && [[ ! "$inputfile" == *.nii.gz ]]; then
                echo "${inputfile} is not nifti" >&2
                exit 1
        fi

        # Get suffix & prefix
        [[ $inputfile == *.nii.gz ]] && suffix=".nii.gz" || suffix=".nii"
        prefix=${inputfile%"$suffix"}
        name=$(basename "$prefix")

        # Pre-process 4D file if applicable
        nvols=$(fslval "$inputfile" dim4)
        nvols=${nvols/ /}
        echo "${name} has ${nvols} volumes"
        if [ "$nvols" -gt 1 ];then
                files=("$prefix"/vol????.nii.gz)
                nvsplit=${#files[@]}
                if [ "$nvsplit" -gt "$nvols" ]; then
                        echo "[${name}] Splitting 4D file"
                        mkdir -p "$prefix"
                        fslsplit "$inputfile" "$prefix"/vol
                else
                        echo "[${name}] 4D is already split, skipping step"

                fi
        fi

        # Extract using FSL

        # Extract using AFNI

        # Extract using Freesurfer

        # Create final mask if using all tools

        # Fill holes

        # Expand if requested

        # Dilate if requested

        # Create QC images if requested

        # Post-process 4D file if applicable

	# Mask brain
}

parse_args() {
        while getopts ":ht:i:p:edq" opt
        do
                case $opt in
                        h) printhelp;;
                        t) tool=${OPTARG,,};; # Convert OPTARG to lower case
                        i) input=$OPTARG;;
                        p) num_proc=$OPTARG;;
                        e) expand=1;;
                        d) dilate=1;;
                        q) qc=1;;
                        \?) echo "Invalid option: -$OPTARG" >&2; exit 1;; # Handle invalid options
                        :) echo "Option -$OPTARG requires an argument." >&2; exit 1;; # Handle missing arguments for options
                esac
        done
}

## Main code
main(){
        # Read arguments
        parse_args "$@"

        # Do checks
        if [[ -z "$input" || -z "$tool" ]]; then
                echo -e "Missing mandatory flags.\n" >&2
                printhelp
        fi

        if ! printf '%s\0' "${valid_tools[@]}" | grep -Fxqz -- "$tool"; then
                echo -e "${tool} is not an acceptable tool for this script.\n" >&2
                printhelp
        fi

        test1=$(fslval -h 2>&1 || true)
        test2=$(3dSkullStrip -h 2>&1 || true)
        test3=$(mri_synthstrip -h 2>&1 || true)
        if { [[ "$test1" == *"command not found"* ]] || \
             [[ "$test2" == *"command not found"* ]] || \
             [[ "$test3" == *"command not found"* ]]; } && \
           { [[ "$tool" == "all_any" ]] || [[ "$tool" == "all_all" ]]; }; then
                echo -e "One of the following tools is not installed or the module is not loaded: fsl, afni, freesurfer.\n" >&2
                printhelp
        elif [[ "$test1" == *"command not found"* && "$tool" == "fsl" ]]; then
                echo -e "fsl is not installed or the module hasn't been loaded.\n" >&2
                printhelp
        elif [[ "$test2" == *"command not found"* && "$tool" == "afni" ]]; then
                echo -e "afni is not installed or the module hasn't been loaded.\n" >&2
                printhelp
        elif [[ "$test3" == *"command not found"* && "$tool" == "freesurfer" ]]; then
                echo -e "freesurfer is not installed or the module hasn't been loaded.\n" >&2
                printhelp
        elif [[ "$test1" == *"command not found"* && "$tool" != "fsl" ]]; then
                echo -e "fsl is not installed or the module hasn't been loaded.\nEven if that's not the selected tool for the brain extraction, fsl is used in other parts of the program.\n" >&2
                printhelp
        fi

        # Get the list of input files
        declare -a inputArray
        if [[ $input == *.txt ]]; then
                readInputListTXT "${input}" inputArray
        elif [[ "$input" == *,* ]]; then
                IFS=',' read -r -a inputArray <<< "${input}"
        else
                inputArray=("${input}")
        fi

        # Correct the size of parallel processes if greater than the number of input files
        if [ "$num_proc" -gt "${#inputArray[@]}" ]; then
                echo -e "You requested to analyze ${num_proc} images in parallel, but there are only ${#inputArray[@]} images.\n \
                Number of parallel processes will be adjusted to ${#inputArray[@]}.\n"
                num_proc=${#inputArray[@]}
        fi

        # Process each input file
        pids=()  # array to store background PIDs
        for inputfile in "${inputArray[@]}"; do
                processNIFTI "${inputfile}" &
                pids+=("$!")

                # Limit the number of parallel jobs
                while (( ${#pids[@]} >= num_proc )); do
                        # wait for the first job in the array
                        wait "${pids[0]}"
                        # remove it from the array
                        pids=("${pids[@]:1}")
                done
        done

        # Wait for remaining jobs
        for pid in "${pids[@]}"; do
                wait "$pid"
        done
}

main "$@"
